// save us one ajax call that we will always have to make
// this can also be grabbed by navigating to /epub_content/metadata.json
window.ReadiumLibraryData = [

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Matt Garrish",
		cover_href: "/epub_content/accessible_epub_3/EPUB/covers/9781449328030_lrg.jpg",
		created_at: "2012-12-14T00:15:13.446Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/accessible_epub_3/EPUB/package.opf",
		fixed_layout: false,
		id: "urn:isbn:9781449328030",
		key: "accessible_epub_3",
		language: "en",
		layout: "",
		modified_date: "2012-10-24T15:30:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/accessible_epub_3/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-02-20",
		publisher: "O’Reilly Media, Inc.",
		rights: "",
		root_url: "epub_content/accessible_epub_3/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: accessible_epub_3-20121024/",
		title: "Accessible EPUB 3",
		updated_at: "2012-12-14T00:24:50.360Z"

	},
	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Jesse Dylan",
		cover_href: "/epub_content/shared_culture/EPUB/images/326261902_3fa36f548d.jpg",
		created_at: "2012-12-14T00:15:13.446Z",
		description: "Multiple video tests (see Navigation Document (toc) for details)",
		epub_version: "3.0",
		file_path: "epub_content/shared_culture/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.cc-shared-culture",
		key: "shared_culture",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-20T12:47:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/shared_culture/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "Creative Commons",
		rights: "",
		root_url: "epub_content/shared_culture/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: cc-shared-culture-20120130/",
		title: "Creative Commons - A Shared Culture",
		updated_at: "2012-12-14T00:25:08.410Z"
	},
	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Charles Madison CurryErle Elsworth Clippinger",
		cover_href: "epub_content/children_lit/EPUB/images/cover.png",
		created_at: "2012-12-14T00:15:13.446Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/children_lit/EPUB/package.opf",
		fixed_layout: false,
		id: "http://www.gutenberg.org/ebooks/25545",
		key: "children_lit",
		language: "en",
		layout: "",
		modified_date: "2010-02-17T04:39:13Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/children_lit/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2008-05-20",
		publisher: "",
		rights: "",
		root_url: "epub_content/children_lit/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: childrens-literature-20120722/",
		title: "Children's LiteratureA Textbook of Sources for Teachers and Teacher-Training Classes",
		updated_at: "2012-12-14T00:26:20.222Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Thomas Crane",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:26:27.743Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/abroad/EPUB/content.opf",
		fixed_layout: false,
		id: "urn:uuid:12C1DF3E-DF35-4FCF-918B-643FF15A7870",
		key: "abroad",
		language: "en",
		layout: "",
		modified_date: "2012-04-09T12:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/abroad/EPUB/content.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "1882",
		publisher: "London ; Belfast ; New York : Marcus Ward & Co.",
		rights: "This work (Abroad EPUB 3), identified by Liza Daly, is free of known copyright restrictions.",
		root_url: "epub_content/abroad/EPUB/content.opf",
		spread: "",
		src_url: "Local Directory: childrens-media-query-20120412/",
		title: "Abroad",
		updated_at: "2012-12-14T00:26:37.013Z"

	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Jesse Dylan",
		cover_href: "epub_content/thomas_cole/EPUB/images/portrait.jpg",
		created_at: "2012-12-14T00:26:39.672Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/thomas_cole/EPUB/cole.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.cole-voyage-of-life",
		key: "thomas_cole",
		language: "en-US",
		layout: "",
		modified_date: "2012-03-20T11:37:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/thomas_cole/EPUB/cole.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.",
		root_url: "epub_content/thomas_cole/EPUB/cole.opf",
		spread: "",
		src_url: "Local Directory: cole-voyage-of-life-20120320/",
		title: "Thomas Cole - The Voyage of Life",
		updated_at: "2012-12-14T00:26:50.641Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "Jesse Dylan",
		cover_href: "epub_content/thomas_cole_tol/EPUB/images/portrait.jpg",
		created_at: "2012-12-14T00:26:52.778Z",
		description: "Mixed reflowable/fixed with an expermental textual overlay (click or tap on paintings to activate)",
		epub_version: "3.0",
		file_path: "epub_content/thomas_cole_tol/EPUB/cole.opf",
		fixed_layout: true,
		id: "code.google.com.epub-samples.cole-voyage-of-life-tol",
		key: "thomas_cole_tol",
		language: "en-US",
		layout: "pre-paginated",
		modified_date: "2012-04-02T12:47:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "landscape",
		package_doc_path: "/epub_content/thomas_cole_tol/EPUB/cole.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "This work is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License.",
		root_url: "epub_content/thomas_cole_tol/EPUB/cole.opf",
		spread: "none",
		src_url: "Local Directory: cole-voyage-of-life-tol-20120405 (1)/",
		title: "Thomas Cole - The Voyage of Life",
		updated_at: "2012-12-14T00:27:02.817Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "EPUB 3 Working Group",
		cover_href: "epub_content/epub_spec30_1/EPUB/img/epub_logo_color.jpg",
		created_at: "2012-12-14T00:27:04.993Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/epub_spec30_1/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.epub30-spec",
		key: "epub_spec30_1",
		language: "en",
		layout: "",
		modified_date: "2012-02-27T16:38:35Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/epub_spec30_1/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/epub_spec30_1/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: epub30-spec-20120228/",
		title: "EPUB 3.0 Specification",
		updated_at: "2012-12-14T00:27:15.759Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Various",
		cover_href: "epub_content/georgia_cfi/EPUB/images/cover.png",
		created_at: "2012-12-14T00:27:18.268Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/georgia_cfi/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.georgia-cfi",
		key: "georgia_cfi",
		language: "en-US",
		layout: "",
		modified_date: "2012-02-07T16:38:35Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/georgia_cfi/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/georgia_cfi/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: georgia-cfi-20120521 (2)/",
		title: "Georgia",
		updated_at: "2012-12-14T00:27:37.702Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Various",
		cover_href: "epub_content/georgia/EPUB/images/cover.png",
		created_at: "2012-12-14T00:27:53.728Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/georgia/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.georgia-pls-ssml",
		key: "georgia",
		language: "en-US",
		layout: "",
		modified_date: "2012-02-07T16:38:35Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/georgia/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/georgia/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: georgia-pls-ssml-20120322 (1)/",
		title: "Georgia",
		updated_at: "2012-12-14T00:28:02.150Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:28:16.113Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/hefty_water/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.hefty.water",
		key: "hefty_water",
		language: "en",
		layout: "",
		modified_date: "2012-03-29T12:00:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/hefty_water/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-03-29",
		publisher: "",
		rights: "",
		root_url: "epub_content/hefty_water/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: hefty-water-20120404/",
		title: "Hefty Water",
		updated_at: "2012-12-14T00:28:27.012Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:28:31.331Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/kusamakura/OPS/package.opf",
		fixed_layout: false,
		id: "http://www.aozora.gr.jp/cards/000148/card776.html",
		key: "kusamakura",
		language: "ja-jp",
		layout: "",
		modified_date: "2012-04-24T00:00:00Z",
		ncx: "ncxtoc",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/kusamakura/OPS/package.opf",
		page_prog_dir: "rtl",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/kusamakura/OPS/package.opf",
		spread: "",
		src_url: "Local Directory: kusamakura-japanese-vertical-writing-20121124/",
		title: "草枕",
		updated_at: "2012-12-14T00:28:43.005Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Herman Melville",
		cover_href: "epub_content/moby_dick/OPS/images/9780316000000.jpg",
		created_at: "2012-12-14T00:28:53.532Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/moby_dick/OPS/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.moby-dick-basic",
		key: "moby_dick",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-18T12:47:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/moby_dick/OPS/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "Harper & Brothers, Publishers",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/moby_dick/OPS/package.opf",
		spread: "",
		src_url: "Local Directory: moby-dick-20120118/",
		title: "Moby-Dick",
		updated_at: "2012-12-14T00:29:31.560Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "Boulet",
		cover_href: "epub_content/page_blanche/EPUB/Image/cover.jpg",
		created_at: "2012-12-14T00:29:34.512Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/page_blanche/EPUB/package.opf",
		fixed_layout: true,
		id: "code.google.com.epub-samples.page-blanche",
		key: "page_blanche",
		language: "fr",
		layout: "pre-paginated",
		modified_date: "2012-08-28T18:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "auto",
		package_doc_path: "/epub_content/page_blanche/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-01-18",
		publisher: "éditions Delcourt",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/page_blanche/EPUB/package.opf",
		spread: "auto",
		src_url: "Local Directory: page-blanche-20121022/",
		title: "Page Blanche",
		updated_at: "2012-12-14T00:30:03.741Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "Boulet",
		cover_href: "epub_content/page_blanche_bitmap/EPUB/Image/cover.jpg",
		created_at: "2012-12-14T00:30:05.990Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/page_blanche_bitmap/EPUB/package.opf",
		fixed_layout: true,
		id: "code.google.com.epub-samples.page-blanche_bitmaps-in-spine",
		key: "page_blanche_bitmap",
		language: "fr",
		layout: "pre-paginated",
		modified_date: "2012-08-08T15:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "auto",
		package_doc_path: "/epub_content/page_blanche_bitmap/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-01-18",
		publisher: "éditions Delcourt",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/page_blanche_bitmap/EPUB/package.opf",
		spread: "auto",
		src_url: "Local Directory: page-blanche-bitmaps-in-spine-20120809/",
		title: "Page Blanche (bitmaps directly in spine)",
		updated_at: "2012-12-14T00:30:12.867Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Pr David Khayat",
		cover_href: "epub_content/anti_cancer/EPUB/Image/cover.jpg",
		created_at: "2012-12-14T00:31:12.800Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/anti_cancer/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.regime-anticancer-arabic",
		key: "anti_cancer",
		language: "ar",
		layout: "",
		modified_date: "2012-08-28T18:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/anti_cancer/EPUB/package.opf",
		page_prog_dir: "rtl",
		paginate_backwards: false,
		pubdate: "2012",
		publisher: "Hachette Antoine",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/anti_cancer/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: regime-anticancer-arabic-20121022/",
		title: "Le Vrai Régime anti-cancer",
		updated_at: "2012-12-14T00:31:25.889Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "佐野眞一",
		cover_href: "epub_content/sash_for_you/OEBPS/images/cover_image.jpg",
		created_at: "2012-12-14T00:31:36.832Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/sash_for_you/OEBPS/sash_for_you.opf",
		fixed_layout: false,
		id: "urn:uuid:E48047B8-3676-4CB7-8C02-966AA64C84FF",
		key: "sash_for_you",
		language: "ja",
		layout: "",
		modified_date: "2012-07-10T09:30:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/sash_for_you/OEBPS/sash_for_you.opf",
		page_prog_dir: "rtl",
		paginate_backwards: false,
		pubdate: "2012-06-26T00:00:00Z",
		publisher: "株式会社ボイジャー",
		rights: "",
		root_url: "epub_content/sash_for_you/OEBPS/sash_for_you.opf",
		spread: "",
		src_url: "Local Directory: sash-for-you-20120827/",
		title: "君に渡す襷として",
		updated_at: "2012-12-14T00:31:48.612Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "Jean-Bernard Pouy",
		cover_href: "epub_content/sous_le_vent/EPUB/Image/cover.jpg",
		created_at: "2012-12-14T00:32:39.572Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/sous_le_vent/EPUB/package.opf",
		fixed_layout: true,
		id: "code.gogle.com.epub-sample.sous-le-vent_svg-in-spine",
		key: "sous_le_vent",
		language: "fr",
		layout: "pre-paginated",
		modified_date: "2012-08-28T18:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "portrait",
		package_doc_path: "/epub_content/sous_le_vent/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-02-01",
		publisher: "éditions Jean-Claude Lattès",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/sous_le_vent/EPUB/package.opf",
		spread: "none",
		src_url: "Local Directory: sous-le-vent_svg-in-spine-20121022/",
		title: "Sous le vent (SVG directly in spine)",
		updated_at: "2012-12-14T00:32:49.394Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "Jean-Bernard Pouy",
		cover_href: "epub_content/sous_le_vent_2/EPUB/Image/9782709641609_Couv.jpg",
		created_at: "2012-12-14T00:32:52.439Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/sous_le_vent_2/EPUB/package.opf",
		fixed_layout: true,
		id: "code.gogle.com.epub-sample.sous-le-vent",
		key: "sous_le_vent_2",
		language: "fr",
		layout: "pre-paginated",
		modified_date: "2012-08-28T18:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "portrait",
		package_doc_path: "/epub_content/sous_le_vent_2/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-02-01",
		publisher: "éditions Jean-Claude Lattès",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/sous_le_vent_2/EPUB/package.opf",
		spread: "auto",
		src_url: "Local Directory: sous-le-vent-20121022/",
		title: "Sous le vent",
		updated_at: "2012-12-14T00:33:03.634Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "ePub Sample project",
		cover_href: "epub_content/svg_in_spine/OPS/Images/cover.svg",
		created_at: "2012-12-14T00:33:05.922Z",
		description: "SVG files are directly called from spine. A page needs to be skipped to display when it is in landscape.",
		epub_version: "3.0",
		file_path: "epub_content/svg_in_spine/OPS/content.opf",
		fixed_layout: true,
		id: "code.google.com.epub-samples.svg-in-spine",
		key: "svg_in_spine",
		language: "en-US",
		layout: "pre-paginated",
		modified_date: "2012-04-12T12:00:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/svg_in_spine/OPS/content.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "ePub Sample",
		rights: "This work is licensed under a Creative Commons Attribution (CC BY SA) license.",
		root_url: "epub_content/svg_in_spine/OPS/content.opf",
		spread: "",
		src_url: "Local Directory: svg-in-spine-20120417/",
		title: "SVG in Spine",
		updated_at: "2012-12-14T00:33:19.469Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "",
		cover_href: "epub_content/trees/EPUB/cover.jpg",
		created_at: "2012-12-14T00:34:37.612Z",
		description: "Test of canvas element and CSS3 multi-column layout",
		epub_version: "3.0",
		file_path: "epub_content/trees/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.trees",
		key: "trees",
		language: "en",
		layout: "",
		modified_date: "2012-04-05T12:47:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/trees/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/trees/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: trees-20120417 (1)/",
		title: "Trees",
		updated_at: "2012-12-14T00:34:46.625Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "T.S. Eliot",
		cover_href: "epub_content/wasteland/EPUB/wasteland-cover.jpg",
		created_at: "2012-12-14T00:34:49.120Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/wasteland/EPUB/wasteland.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.wasteland-basic",
		key: "wasteland",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-18T12:47:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/wasteland/EPUB/wasteland.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2011-09-01",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/wasteland/EPUB/wasteland.opf",
		spread: "",
		src_url: "Local Directory: wasteland-20120118 (1)/",
		title: "The Waste Land",
		updated_at: "2012-12-14T00:34:59.873Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "T.S. Eliot",
		cover_href: "epub_content/wasteland_otf/EPUB/wasteland-cover.jpg",
		created_at: "2012-12-14T00:35:10.272Z",
		description: "Using OTF fonts, fallback to sans-serif system font",
		epub_version: "3.0",
		file_path: "epub_content/wasteland_otf/EPUB/wasteland.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.wasteland-otf",
		key: "wasteland_otf",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-18T12:47:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/wasteland_otf/EPUB/wasteland.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2011-09-01",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/wasteland_otf/EPUB/wasteland.opf",
		spread: "",
		src_url: "Local Directory: wasteland-otf-20120118/",
		title: "The Waste Land",
		updated_at: "2012-12-14T00:35:23.875Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "T.S. Eliot",
		cover_href: "epub_content/wasteland_otf_obfs/EPUB/wasteland-cover.jpg",
		created_at: "2012-12-14T00:35:26.256Z",
		description: "OTF font obfuscated using algorithm defined in OCF 3.0, fallback to sans-serif system font",
		epub_version: "3.0",
		file_path: "epub_content/wasteland_otf_obfs/EPUB/wasteland.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.wasteland-otf-obfuscated",
		key: "wasteland_otf_obfs",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-18T12:47:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/wasteland_otf_obfs/EPUB/wasteland.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2011-09-01",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/wasteland_otf_obfs/EPUB/wasteland.opf",
		spread: "",
		src_url: "Local Directory: wasteland-otf-obf-20120118 (1)/",
		title: "The Waste Land",
		updated_at: "2012-12-14T00:35:43.726Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "T.S. Eliot",
		cover_href: "epub_content/wasteland_woff/EPUB/wasteland-cover.jpg",
		created_at: "2012-12-14T00:35:46.783Z",
		description: "Using WOFF fonts, fallback to sans-serif system font",
		epub_version: "3.0",
		file_path: "epub_content/wasteland_woff/EPUB/wasteland.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.wasteland-woff",
		key: "wasteland_woff",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-18T12:47:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/wasteland_woff/EPUB/wasteland.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2011-09-01",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/wasteland_woff/EPUB/wasteland.opf",
		spread: "",
		src_url: "Local Directory: wasteland-woff-20120118/",
		title: "The Waste Land",
		updated_at: "2012-12-14T00:35:59.408Z"	
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "T.S. Eliot",
		cover_href: "epub_content/wasteland_woff_obfs/EPUB/wasteland-cover.jpg",
		created_at: "2012-12-14T00:36:03.859Z",
		description: "WOFF font obfuscated using algorithm defined in OCF 3.0, fallback to sans-serif system font",
		epub_version: "3.0",
		file_path: "epub_content/wasteland_woff_obfs/EPUB/wasteland.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.wasteland-woff-obfuscated",
		key: "wasteland_woff_obfs",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-18T12:47:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/wasteland_woff_obfs/EPUB/wasteland.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2011-09-01",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/wasteland_woff_obfs/EPUB/wasteland.opf",
		spread: "",
		src_url: "Local Directory: wasteland-woff-obf-20120118 (1)/",
		title: "The Waste Land",
		updated_at: "2012-12-14T00:36:13.585Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "E.L. Starr",
		cover_href: "epub_content/widgets/EPUB/images/cover.jpg",
		created_at: "2012-12-14T00:36:15.860Z",
		description: "",
		epub_version: "3.0",
		file_path: "/epub_content/widgets/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.widget-figure-gallery",
		key: "widgets",
		language: "en-US",
		layout: "",
		modified_date: "2012-04-05T21:03:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/widgets/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-01-17",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "/epub_content/widgets/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: widget-figure-gallery-20121022/",
		title: "EPUB Widgets: Figure Gallery",
		updated_at: "2012-12-14T00:36:25.987Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "E.L. Starr",
		cover_href: "epub_content/widgets_quiz/EPUB/images/cover.jpg",
		created_at: "2012-12-14T00:36:28.253Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/widgets_quiz/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.widget-quiz",
		key: "widgets_quiz",
		language: "en-US",
		layout: "",
		modified_date: "2012-04-05T21:03:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/widgets_quiz/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-01-17",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/widgets_quiz/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: widget-quiz-20121022/",
		title: "EPUB Widgets: Quiz",
		updated_at: "2012-12-14T00:36:36.163Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "-epub-media-overlay-active",
		apple_fixed: false,
		author: "Herman Melville",
		cover_href: "epub_content/moby_dick_mo/OPS/images/9780316000000.jpg",
		created_at: "2012-12-14T00:32:39.572Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/moby_dick_mo/OPS/package.opf",
		fixed_layout: false,
		id: "urn:isbn:9780316000000",
		key: "moby_dick_mo",
		language: "en-US",
		layout: "",
		modified_date: "2012-01-13T01:13:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/moby_dick_mo/OPS/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "Harper & Brothers, Publishers",
		rights: "",
		root_url: "epub_content/moby_dick_mo/OPS/package.opf",
		spread: "",
		src_url: "Local Directory: moby-dick-mo-20120214 (2)/",
		title: "Moby-Dick",
		updated_at: "2012-12-14T00:43:18.958Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "",
		cover_href: "epub_content/mahabharata/EPUB/img/mahabharata.jpg",
		created_at: "2012-12-14T00:43:22.302Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/mahabharata/EPUB/mahabharata.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.mahabarata",
		key: "mahabharata",
		language: "sa",
		layout: "",
		modified_date: "2012-03-01T12:47:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/mahabharata/EPUB/mahabharata.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/mahabharata/EPUB/mahabharata.opf",
		spread: "",
		src_url: "Local Directory: mahabharata-20120305/",
		title: "महाभारत",
		updated_at: "2012-12-14T00:47:23.749Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Robert A. Beezer",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:47:28.528Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/linear_algebra/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.linear-algebra",
		key: "linear_algebra",
		language: "en",
		layout: "",
		modified_date: "2012-03-05T12:47:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/linear_algebra/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "This work is shared with the public using the GNU Free Documentation License, Version 1.2.",
		root_url: "epub_content/linear_algebra/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: linear-algebra-20120306 (1)/",
		title: "A First Course in Linear Algebra",
		updated_at: "2012-12-14T00:48:22.950Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "W3C® (MIT, ERCIM, Keio)",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:48:28.618Z",
		description: "This document describes requirements for general Japanese layout realized with technologies like CSS, SVG and XSL-FO. The document is mainly based on a standard for Japanese layout, JIS X 4051, however, it also addresses areas which are not covered by JIS X 4051. This second version of the document contains a significant amount of additional information related to hanmen design, such as handling headings, placement of illustrations and tables, handling of notes and reference marks, etc.",
		epub_version: "3.0",
		file_path: "epub_content/req_japanese_layout/OEBPS/jlreq.opf",
		fixed_layout: false,
		id: "http://www.w3.org/TR/2012/NOTE-jlreq-20120403/",
		key: "req_japanese_layout",
		language: "en",
		layout: "",
		modified_date: "2012-04-03T00:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/req_japanese_layout/OEBPS/jlreq.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-04-03",
		publisher: "W3C® (MIT, ERCIM, Keio)",
		rights: "Copyright © 2012 W3C® (MIT, ERCIM, Keio), All Rights Reserved. W3C liability, trademark and document use rules apply.",
		root_url: "epub_content/req_japanese_layout/OEBPS/jlreq.opf",
		spread: "",
		src_url: "Local Directory: jlreq_20120525/",
		title: "Requirements for Japanese Text Layout",
		updated_at: "2012-12-14T00:49:22.024Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "W3C® (MIT, ERCIM, Keio)",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:49:26.426Z",
		description: "この文書は，CSS，SVGおよびXSL-FOなどの技術で実現が求められる一般的な日本語組版の要件を記述したものです．この文書は，主としてJIS X 4051（日本語組版規則）に基づいていますが，一部，JIS X 4051に記載されていない事項にも言及しています．この第2版は，見出しの扱い，図版や表の配置，注や合印等の版面デザインに関する多くの情報が増補されています. ",
		epub_version: "3.0",
		file_path: "epub_content/req_japanese_layout_2/OEBPS/jlreq_ja.opf",
		fixed_layout: false,
		id: "http://www.w3.org/TR/2012/NOTE-jlreq-20120403/ja/",
		key: "req_japanese_layout_2",
		language: "ja",
		layout: "",
		modified_date: "2012-04-03T00:00:00Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/req_japanese_layout_2/OEBPS/jlreq_ja.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2012-04-03",
		publisher: "W3C® (MIT, ERCIM, Keio)",
		rights: "Copyright © 2012 W3C® (MIT, ERCIM, Keio), All Rights Reserved. W3C liability, trademark and document use rules apply.",
		root_url: "epub_content/req_japanese_layout_2/OEBPS/jlreq_ja.opf",
		spread: "",
		src_url: "Local Directory: jlreq_20120525_ja (1)/",
		title: "日本語組版処理の要件（日本語版）",
		updated_at: "2012-12-14T00:50:26.124Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "אורי עידן",
		cover_href: "epub_content/israeli_sailing/OEPBS/israelsailing.jpg",
		created_at: "2012-12-14T00:50:29.804Z",
		description: "כשנתיים לאחר תום הסיפור רחשי הלב האחרונים אבישי גר ביאכטה שלו במרינה הרצליה. לפתע הוא מקבל ביקור בלתי צפוי. ביקור זה מוביל להרפתקאות מעניינות לאורך חופי הארץ.↵כמו בשאר הספרים על אבישי, אין צורך לקרוא את הספרים האחרים על מנת להבין סיפור זה.",
		epub_version: "3.0",
		file_path: "epub_content/israeli_sailing/OEPBS/content.opf",
		fixed_layout: false,
		id: "http://www.thestories.org/book/israelsailing",
		key: "israeli_sailing",
		language: "he",
		layout: "",
		modified_date: "2012-08-19T18:03:16Z",
		ncx: "ncx",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/israeli_sailing/OEPBS/content.opf",
		page_prog_dir: "rtl",
		paginate_backwards: false,
		pubdate: "2012-08-19",
		publisher: "אורי עידן",
		rights: "Creative commons 2.5 CC-BY-SA",
		root_url: "epub_content/israeli_sailing/OEPBS/content.opf",
		spread: "",
		src_url: "Local Directory: israelsailing_20120909/",
		title: "מפליגים בישראל",
		updated_at: "2012-12-14T00:50:43.914Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:50:46.484Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/character_1/OPS/package.opf",
		fixed_layout: true,
		id: "urn:uuid:ACA8C671-6C1F-1014-8433-7416564D7508",
		key: "character_1",
		language: "ja-jp",
		layout: "pre-paginated",
		modified_date: "2012-08-14T13:54:00Z",
		ncx: "ncxtoc",
		open_to_spread: false,
		orientation: "portrait",
		package_doc_path: "/epub_content/character_1/OPS/package.opf",
		page_prog_dir: "rtl",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/character_1/OPS/package.opf",
		spread: "landscape",
		src_url: "Local Directory: haruko-jpeg-20120814/",
		title: "ハルコさんの彼氏",
		updated_at: "2012-12-14T00:50:58.638Z"
	},

	{
		active_class: "",
		apple_fixed: false,
		author: "",
		cover_href: "/images/library/missing-cover-image.png",
		created_at: "2012-12-14T00:51:01.509Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/character_2/OPS/package.opf",
		fixed_layout: true,
		id: "urn:uuid:A649F639-6C1F-1014-8CC3-F813564D7508",
		key: "character_2",
		language: "ja-jp",
		layout: "pre-paginated",
		modified_date: "2012-05-24T00:00:00Z",
		ncx: "ncxtoc",
		open_to_spread: false,
		orientation: "portrait",
		package_doc_path: "/epub_content/character_2/OPS/package.opf",
		page_prog_dir: "rtl",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/character_2/OPS/package.opf",
		spread: "landscape",
		src_url: "Local Directory: haruko-html-jpeg-20120524 (1)/",
		title: "ハルコさんの彼氏",
		updated_at: "2012-12-14T00:51:15.601Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "EPUB 3 Working Group",
		cover_href: "epub_content/epub_spec30_2/EPUB/img/epub_logo_color.jpg",
		created_at: "2012-12-14T00:51:18.274Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/epub_spec30_2/EPUB/package.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.epub30-spec",
		key: "epub_spec30_2",
		language: "en",
		layout: "",
		modified_date: "2012-02-27T16:38:35Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/epub_spec30_2/EPUB/package.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "",
		publisher: "",
		rights: "",
		root_url: "epub_content/epub_spec30_2/EPUB/package.opf",
		spread: "",
		src_url: "Local Directory: epub30-spec-20121128/",
		title: "EPUB 3.0 Specification",
		updated_at: "2012-12-14T00:51:31.151Z"
	},

	{
		current_margin: 1,
		current_theme: "default-theme",
		font_size: 10,
		two_up: false,
		pagination_mode: "single",
		active_class: "",
		apple_fixed: false,
		author: "Collectif",
		cover_href: "epub_content/guide_hachette/EPUB/Image/cover.jpg",
		created_at: "2012-12-14T00:51:34.071Z",
		description: "",
		epub_version: "3.0",
		file_path: "epub_content/guide_hachette/EPUB/content.opf",
		fixed_layout: false,
		id: "code.google.com.epub-samples.guide-des-vins_header-and-footer",
		key: "guide_hachette",
		language: "fr",
		layout: "",
		modified_date: "2012-10-02T18:00:00Z",
		ncx: "",
		open_to_spread: false,
		orientation: "",
		package_doc_path: "/epub_content/guide_hachette/EPUB/content.opf",
		page_prog_dir: "",
		paginate_backwards: false,
		pubdate: "2010",
		publisher: "Hachette Pratique",
		rights: "This work is shared with the public using the Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) license.",
		root_url: "epub_content/guide_hachette/EPUB/content.opf",
		spread: "",
		src_url: "Local Directory: GhV-oeb-page-20121015/",
		title: "Guide Hachette des Vins 2011",
		updated_at: "2012-12-14T00:52:11.119Z"
	},
]
// This is the namespace and initialization code that is used by
// by the web served version of readium. It is not included in
// the chrome extension at all.

if( !window.Readium ) {
	window.Readium = {
		Models: {},
		Collections: {},
		Views: {},
		Routers: {},
		Utils: {},
		Init: function() {
			window.options = Readium.Models.ReadiumOptions.getInstance();
			window.optionsView = new Readium.Views.ReadiumOptionsView({model: window.options});
				
			window.Library = new Readium.Collections.LibraryItems(window.ReadiumLibraryData);
			window.lib_view = new Readium.Views.LibraryItemsView({collection: window.Library});
			//window.fp_view = new Readium.Views.FilePickerView();
			window.router = new Readium.Routers.ApplicationRouter({collection: window.Library});

			Backbone.history.start({pushState: false});
			// window.Library.fetch();
			window.Library.trigger('reset');

var hc = $('#library-items-container').hasClass("row-view");
$("#block-view-btn").attr('aria-pressed', hc ? 'false' : 'true');
$("#row-view-btn").attr('aria-pressed', hc ? 'true' : 'false');
			
			$("#block-view-btn").click(function(e) {
$("#block-view-btn").attr('aria-pressed', 'true');
$("#row-view-btn").attr('aria-pressed', 'false');
				$('#library-items-container').addClass("block-view").removeClass("row-view")
			});
			$("#row-view-btn").click(function(e) {
$("#block-view-btn").attr('aria-pressed', 'false');
$("#row-view-btn").attr('aria-pressed', 'true');
				$('#library-items-container').addClass("row-view").removeClass("block-view")
			});

$('#bar-logo').attr('aria-pressed', 'false');
$('#readium-info').on('shown', function(){
$('#version-info').focus();
setTimeout(function(){
$('#bar-logo').attr('aria-pressed', 'true');
}, 1);
})
.on('hidden', function(){
setTimeout(function(){
$('#bar-logo').attr('aria-pressed', 'false').focus();
}, 1);
});

$('#options-btn').attr('aria-pressed', 'false');
$('#readium-options-modal').on('shown', function(){
$('#options-heading').focus();
setTimeout(function(){
$('#options-btn').attr('aria-pressed', 'true');
}, 1);
})
.on('hidden', function(){
setTimeout(function(){
$('#options-btn').attr('aria-pressed', 'false').focus();
}, 1);
});

$(Acc.detailed).each(function(i, o){
$(o).on('shown', function(){
setTimeout(function(){
$(o).parent().find('a.info-icon, a.btn.details').attr('aria-pressed', 'true');
}, 1);
})
.on('hidden', function(){
setTimeout(function(){
$(o).parent().find('a.info-icon, a.btn.details').attr('aria-pressed', 'false');
}, 1);
}).modal('hide');
});

		}
	};
};

$(function() {
	// call the initialization code when the dom is loaded
	window.Readium.Init();
});
Readium.HttpFileApi = function(initCallback) {
    var api = {
        readTextFile: function(path, readCallback, errorCallback) {
            $.ajax({
                //'cache' : false,
                'url' : path,
                'dataType' : 'text',
                'success' : function(data, textStatus, jqXHR) {
                    readCallback(data, jqXHR)
                },
                'error' : function(data, textStatus, jqXHR) {
                    errorCallback(data, textStatus, jqXHR)
                }
            })
        },

        getFsUri: function(path, successCallback, errorCallback) {
            successCallback(document.location.protocol + '//' + document.location.host + path)
        }
    }

    return function ( callback ) {
        callback(api);
        return api;
    }
}();

// patch in:
// TODO: Find a way to easily patch in
Readium.FileSystemApi = Readium.HttpFileApi

// based on http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
Readium.Utils.Guid = function() {
   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    	var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
    	return v.toString(16);
	});
};

// roughly based on http://documentcloud.github.com/backbone/docs/backbone-localstorage.html
Readium.Utils.LocalStorageAdaptor = function(storeName) {

	var _data;

	var save = function() {
		localStorage.setItem(storeName, JSON.stringify(_data));
	};

	var create = function(model) {
		if (!model.id) model.id = model.attributes.id = guid();
		_data[model.id] = model;
		save();
		return model;
	};

	var update = function(model) {
		_data[model.id] = model;
		save();
		return model;
	};

	var find = function(model) {
		return _data[model.id];
	};

	var findAll = function() {
		return _.values(_data);
	};


	var destroy = function(model) {
		delete _data[model.id];
		save();
		return model;
	};

	return function(method, model, options) {

		var resp;
		var strData = localStorage.getItem(storeName);
		_data = ( strData && JSON.parse(strData)) || {};

		switch (method) {
			case "read":    resp = model.id ? find(model) : findAll(); break;
			case "create":  resp = create(model);                            break;
			case "update":  resp = update(model);                            break;
			case "delete":  resp = destroy(model);                           break;
		}

		if (resp) {
			if(options.success) {
				options.success(resp);
			}
		} else {
			if(options.error) {
				options.error("Record not found");	
			}
		}
	};

};
Readium.Utils.setCookie = function(c_name,value,exdays) {
	var exdate=new Date();
	exdate.setDate(exdate.getDate() + exdays);
	var c_value=escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
	document.cookie=c_name + "=" + c_value;
}


Readium.Utils.getCookie = function(c_name) {
	var i, x, y, ARRcookies=document.cookie.split(";");
	for (i = 0; i < ARRcookies.length; i++) {
		x = ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
		y = ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
		x = x.replace(/^\s+|\s+$/g,"");
		if ( x == c_name ) {
			return unescape(y);
		}
	}
}

Readium.Utils.trimString = function(str) {
	return str.replace(/^\s+|\s+$/g, '');
}
if (window.chrome != null && window.chrome.i18n != null) {
	Handlebars.registerHelper('orUnknown', function(str) {
	  	return str ? str : chrome.i18n.getMessage("i18n_unknown");
	});

	Handlebars.registerHelper('fetchInzMessage', function(key) {
		return new Handlebars.SafeString(chrome.i18n.getMessage(key));
	});	
} else {
	Handlebars.registerHelper('orUnknown', function(str) {
	  	return str ? str : "Unknown";
	});

	Handlebars.registerHelper('fetchInzMessage', function(key) {
		return key.substring(key.indexOf('_') + 1);
	});	
}
Readium.Models.ReadiumOptions = Backbone.Model.extend({

	initialize: function() {
		this.set("id", "singleton");
	},

	defaults: {
		hijack_epub_urls: false,
		verbose_unpacking: true,
		paginate_everything: true
	},

	sync: Readium.Utils.LocalStorageAdaptor("READIUM_OPTIONS")
}, {
	getInstance: function() {
		var instance = new Readium.Models.ReadiumOptions();
		instance.fetch({
			error: function() {
				localStorage.setItem("READIUM_OPTIONS", "");
				instance.save();
			}
		});
		return instance;
	}
});
// todo move this stuff into the proper namespaces
Readium.Models.LibraryItem = Backbone.Model.extend({

	idAttribute: "key",
	
	getViewBookUrl: function(book) {
		return "/viewer.html?book=" + this.get('key');
	},

	openInReader: function() {
		window.location = this.getViewBookUrl();
	}

});

Readium.Collections.LibraryItems = Backbone.Collection.extend({

	model: Readium.Models.LibraryItem,

	url: "/epub_content/metadata.json"
	
});

Readium.Views.LibraryItemView = Backbone.View.extend({

	tagName: 'div',

	className: "book-item clearfix",

	initialize: function() {
		_.bindAll(this, "render");	
		this.template = Handlebars.templates.library_item_template;
Acc.detailed.push('#details-modal-' + this.model.get('key'));
	},

	render: function() {
		var renderedContent = this.template({data: this.model.toJSON()});
		$(this.el).html(renderedContent);
		this.$(".delete").toggle(false);
		return this;
	},

	events: {
		"click .delete": function(e) {
			e.preventDefault();
			var confMessage;
			var selector = "#details-modal-" + this.model.get('key');
			confMessage  = "Are you sure you want to perminantly delete " 
			confMessage += this.model.get('title');
			confMessage += "?";


			if(confirm(confMessage)) {
				$(selector).modal('hide');
				this.model.destroy();
				this.remove();
			}
		},

		"click .read": function(e) {
			this.model.openInReader();
		}
		
	}
});

Readium.Views.LibraryItemsView = Backbone.View.extend({
	tagName: 'div',

	id: "library-items-container",

	className: 'row-view clearfix',

	

	initialize: function() {
		this.template = Handlebars.templates.library_items_template;
		this.collection.bind('reset', this.render, this);
		this.collection.bind('add',   this.addOne, this);
	},

	render: function() {
		var collection = this.collection;
		var $container = $(this.el);
		$container.html(this.template({}));
		this.$('#empty-message').toggle(this.collection.isEmpty());

		collection.each(function(item) {
			var view = new Readium.Views.LibraryItemView({
				model: item,
				collection: collection,
				id: item.get('id')
			});
			$container.append( view.render().el );

		});
		
		// i dunno if this should go here
		$('#library-books-list').html(this.el)
		return this;
	},

	addOne: function(book) {
		var view = new LibraryItemView({
			model: book,
			collection: this.collection,
			id: book.get('id')
		});
		// we are adding so this should always be hidden!
		this.$('#empty-message').toggle(false);
		$(this.el).append( view.render().el );
	},

	events: {
		
	}
});


Readium.Views.ExtractItemView = Backbone.View.extend({
	
	el: $('#progress-container')[0],

	initialize: function() {	
		this.template = Handlebars.templates.extracting_item_template;
		this.model.bind('change', this.render, this);
		this.model.bind("change:error", this.extractionFailed, this);
	},

	render: function() {
		var $el = $(this.el);
		if( this.model.get('extracting') ) {
			$el.html(this.template(this.model.toJSON()));
			$el.show("slow");
		}
		else {
			$el.hide("slow");
		}
		return this;
	},

	extractionFailed: function(msg) {
		alert(this.model.get("error"));
		this.model.set("extracting", false);
	}

});

Readium.Views.ReadiumOptionsView = Backbone.View.extend({
	el: "#readium-options-modal",

	initialize: function() {
		this.model.on("change", this.render, this);
		this.render();
		$(this.el).on('shown', function(){
			$('#options-heading').focus();
			setTimeout( function() {
				$('#options-btn').attr('aria-pressed', 'true');
			}, 1);
		}).on('hidden', function(){
			setTimeout( function(){
				$('#options-btn').attr('aria-pressed', 'false').focus();
			}, 1);
		});
	},

	render: function() {
		var m = this.model;
		this.$('#paginate_everything').prop('checked', m.get("paginate_everything"));
		this.$('#verbose_unpacking').prop('checked', m.get("verbose_unpacking"));
		this.$('#hijack_epub_urls').prop('checked', m.get("hijack_epub_urls"));
	},

	events: {
		"change #verbose_unpacking": "updateSettings",
		"change #hijack_epub_urls": "updateSettings",
		"change #paginate_everything": "updateSettings",
		"click #save-settings-btn": "save"
		},

		updateSettings: function() {
			var hijack = this.$('#hijack_epub_urls').prop('checked')
			var unpack = this.$('#verbose_unpacking').prop('checked')
			var paginate = this.$('#paginate_everything').prop('checked')
			
		this.model.set({"verbose_unpacking": unpack,
						"hijack_epub_urls": hijack,
						"paginate_everything": paginate});
		},

		save: function() {
			this.model.save();
			this.$el.modal("hide");
		}

});

Readium.Routers.ApplicationRouter = Backbone.Router.extend({
	initialize: function(options) {
		this.collection = options.collection;
	},


	routes: {
		"view_book/:id": "openBook",
		"": "showLibrary"
	},

	openBook: function(key) {
		this.showViewer();
		var book_attrs = this.collection.get(key).toJSON();
		if(book_attrs.fixed_layout) {
			console.log('initializing fixed layout book');
			window._book = new Readium.Models.AppleFixedEbook(book_attrs);
		}
		else {
			console.log('initializing reflowable book');
			window._book = new Readium.Models.ReflowableEbook(book_attrs);
		}
		
		window._libraryView = new Readium.Views.ViewerApplicationView({
			model: window._book
		});
		window._libraryView.render();
	},

	showLibrary: function() {
		$("#readium-library-activity").toggle(true);
		$("#readium-viewer-activity").toggle(false);
	},

	showViewer: function() {
		$("#readium-library-activity").toggle(false);
		$("#readium-viewer-activity").toggle(true);
	},

	splat_handler: function(splat) {
		console.log(splat);
	}

}); 
(function() {
  var template = Handlebars.template, templates = Handlebars.templates = Handlebars.templates || {};
templates['binding_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  


  return "<iframe scrolling=\"no\" \n		frameborder=\"0\" \n		marginwidth=\"0\" \n		marginheight=\"0\" \n		width=\"100%\" \n		height=\"100%\" \n		class='binding-sandbox'>\n</iframe>";});
templates['extracting_item_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<h5>";
  foundHelper = helpers.log_message;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.log_message; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "</h5>\n<div class=\"progress progress-striped progress-success active \">	\n		<div role=\"status\" aria-live=\"assertive\" aria-relevant=\"all\" class=\"bar\" style=\"width: ";
  foundHelper = helpers.progress;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.progress; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "%;\"></div>\n</div>";
  return buffer;});
templates['fixed_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"fixed-page-margin\">\n	<iframe scrolling=\"no\" \n			frameborder=\"0\" \n			marginwidth=\"0\" \n			marginheight=\"0\" \n			width=\"";
  foundHelper = helpers.width;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.width; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "px\" \n			height=\"";
  foundHelper = helpers.height;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.height; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "px\" \n			src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\"\n			title=\"";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\"\n			class='content-sandbox'>\n	</iframe>\n</div>";
  return buffer;});
templates['image_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"fixed-page-margin\">\n	<img src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\" alt=\"\" />\n</div>";
  return buffer;});
templates['library_item_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;


  buffer += "<div class='info-wrap'>\n	<div class='caption book-info'>\n		<h2 class='green info-item title'>";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "</h2>\n		<div class='info-item author'>";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.author;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='info-item epub-version'>ePUB ";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.epub_version;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>		\n	</div>\n	\n	<img class='cover-image read' src='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.cover_href;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' width='150' height='220' alt='Open ePUB ";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "'>\n	\n	<a href=\"#details-modal-";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\" class=\"info-icon\" aria-pressed=\"true\" data-toggle=\"modal\" role=\"button\">\n		<img class='info-icon pull-right' src='/images/library/info-icon.png' height=\"39px\" width=\"39px\" alt='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + " information'>\n	</a>\n</div>\n\n<div class=\"caption buttons\">\n	<a href=\"#todo\" class=\"btn read\" data-book='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' role='button'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_read", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_read", {hash:{}});
  buffer += escapeExpression(stack1) + "</a>\n	<a href=\"#details-modal-";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\" aria-pressed=\"true\" class=\"btn details\" data-toggle=\"modal\" role=\"button\">\n		";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_details", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_details", {hash:{}});
  buffer += escapeExpression(stack1) + "\n	</a>\n</div>\n\n<div id='details-modal-";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.key;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' class='modal fade details-modal'>\n<div class=\"offscreenText\"> Details Start </div>\n	<div class=\"pull-left modal-cover-wrap\">\n		<img class='details-cover-image' src='";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.cover_href;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "' width='150' height='220' alt='ePUB cover'>\n		<div class=\"caption modal-buttons\">\n			<a href=\"#\" class=\"btn read\" data-book='<%= data.key %>' role='button'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_read", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_read", {hash:{}});
  buffer += escapeExpression(stack1) + "</a>\n			<a class=\"btn btn-danger delete pull-right\" role='button'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_delete", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_delete", {hash:{}});
  buffer += escapeExpression(stack1) + "</a>\n		</div>\n	</div>\n	<div class='caption modal-book-info'>\n		<h3 class='green modal-title'>";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "</h3>\n		<div class='modal-detail gap'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_author", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_author", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.author;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_publisher", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_publisher", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.publisher;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_pub_date", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_pub_date", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.pubdate;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_modified_date", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_modified_date", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.modified_date;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail gap'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_id", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_id", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.id;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail green'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_epub_version", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_epub_version", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.epub_version;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n		<div class='modal-detail'>";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_created_at", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_created_at", {hash:{}});
  buffer += escapeExpression(stack1);
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.created_at;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "</div>\n	</div>\n	<div class='modal-detail source'>\n	<span class='green' style=\"padding-right: 10px\">";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_source", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_source", {hash:{}});
  buffer += escapeExpression(stack1) + "</span>\n		";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.src_url;
  foundHelper = helpers.orUnknown;
  stack1 = foundHelper ? foundHelper.call(depth0, stack1, {hash:{}}) : helperMissing.call(depth0, "orUnknown", stack1, {hash:{}});
  buffer += escapeExpression(stack1) + "\n	</div>\n<div class=\"offscreenText\"> Details End </div>\n</div>			";
  return buffer;});
templates['library_items_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div id='empty-message'>\n	<p id='empty-message-text' class='green'>\n		";
  foundHelper = helpers.fetchInzMessage;
  stack1 = foundHelper ? foundHelper.call(depth0, "i18n_add_items", {hash:{}}) : helperMissing.call(depth0, "fetchInzMessage", "i18n_add_items", {hash:{}});
  buffer += escapeExpression(stack1) + "\n	</p>\n	<img id='empty-arrow' src='/images/library/empty_library_arrow.png' alt='Try adding an ePUB' />\n</div>";
  return buffer;});
templates['ncx_nav_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<li class=\"nav-elem\">\n	<a href=\"";
  foundHelper = helpers.href;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.href; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\">";
  foundHelper = helpers.text;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.text; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "</a>\n</li>";
  return buffer;});
templates['reflowing_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"flowing-wrapper\">\n	<iframe scrolling=\"no\" \n			frameborder=\"0\" \n			marginwidth=\"0\" \n			marginheight=\"0\" \n			width=\"50%\" \n			height=\"100%\" \n			title=\"";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\"\n			src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\"\n			id=\"readium-flowing-content\">\n	</iframe>\n</div>";
  return buffer;});
templates['scrolling_page_template'] = template(function (Handlebars,depth0,helpers,partials,data) {
  helpers = helpers || Handlebars.helpers;
  var buffer = "", stack1, foundHelper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div id=\"scrolling-wrapper\">\n	<iframe scrolling=\"yes\" \n			frameborder=\"0\" \n			marginwidth=\"0\" \n			marginheight=\"0\" \n			width=\"100%\" \n			height=\"100%\" \n			title=\"";
  stack1 = depth0.data;
  stack1 = stack1 == null || stack1 === false ? stack1 : stack1.title;
  stack1 = typeof stack1 === functionType ? stack1() : stack1;
  buffer += escapeExpression(stack1) + "\"\n			src=\"";
  foundHelper = helpers.uri;
  if (foundHelper) { stack1 = foundHelper.call(depth0, {hash:{}}); }
  else { stack1 = depth0.uri; stack1 = typeof stack1 === functionType ? stack1() : stack1; }
  buffer += escapeExpression(stack1) + "\"\n			id=\"readium-scrolling-content\">\n	</iframe>\n</div>";
  return buffer;});
})();
(function(window){

window.Acc = {
detailed: [],
title: '',
page: '',
RadioGroup: function(radioGroupObjId, defaultRadioValSelector, callback) {
var rgo = $('#' + radioGroupObjId).get(0),
track = {}, that = this,
select = function(index, force) {
$('#' + rgo.id + ' > *').attr( {
tabindex : '-1',
'aria-selected' : 'false',
'aria-checked' : 'false'
});
$(that.childNodes[index]).attr( {
tabindex : '0',
'aria-selected' : 'true',
'aria-checked' : 'true'
});
if (force) $(that.childNodes[index]).focus();
that.selected = that.childNodes[index];
that.index = index;
if (callback && typeof callback === 'function') callback(that.childNodes[index], that.childNodes);
};
that.childNodes = $('#' + rgo.id + ' > *').each(function(i, o) {
track[o.id] = i;
track.max = i + 1;
$(o).attr( {
tabindex : '-1',
'aria-selected' : 'false',
'aria-checked' : 'false',
'aria-posinset' : track.max
});
}).get();
$('#' + rgo.id + ' > *').attr('aria-setsize', track.max)
.bind( {
click: function(ev) {
if (this != that.selected) select(track[this.id]);
},
keydown : function(ev) {
var k = ev.which || ev.keyCode;
if (k == 37 || k == 38) {
if (that.index > 0)
select(that.index - 1, true);
else
select(track.max - 1, true);
}
else if (k == 39 || k == 40) {
if (that.index < (track.max - 1))
select(that.index + 1, true);
else
select(0, true);
ev.stopPropagation();
}
}
});
that.set = function(id) {
select(track[id]);
};
select(track[$('#' + radioGroupObjId + defaultRadioValSelector).get(0).id]);
}
};

})(window);
/*
 * Readium i18n functions
 *
 */

// var elems = document.getElementsByTagName("span");
// for (var i = 0; i<elems.length; i++) {
//         if (elems[i].id == null) {
//                 continue;
//         }
//         if (elems[i].id.indexOf("i18n_html_", 0) == 0) {
//                 var msg = chrome.i18n.getMessage(elems[i].id);
//                 if (msg != "") {
//                         elems[i].innerHTML = msg;
//                 }
//         } else if (elems[i].id.indexOf("i18n_", 0) == 0) {
//                 var msg = chrome.i18n.getMessage(elems[i].id);
//                 if (msg != "") {
//                         elems[i].innerText = msg;
//                 }
//         }
// }
(function(global) {
    
    var EPUBcfi = {};

    EPUBcfi.Parser = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "fragment": parse_fragment,
        "path": parse_path,
        "local_path": parse_local_path,
        "indexStep": parse_indexStep,
        "indirectionStep": parse_indirectionStep,
        "terminus": parse_terminus,
        "idAssertion": parse_idAssertion,
        "textLocationAssertion": parse_textLocationAssertion,
        "parameter": parse_parameter,
        "csv": parse_csv,
        "valueNoSpace": parse_valueNoSpace,
        "value": parse_value,
        "escapedSpecialChars": parse_escapedSpecialChars,
        "number": parse_number,
        "integer": parse_integer,
        "space": parse_space,
        "circumflex": parse_circumflex,
        "doubleQuote": parse_doubleQuote,
        "squareBracket": parse_squareBracket,
        "parentheses": parse_parentheses,
        "comma": parse_comma,
        "semicolon": parse_semicolon,
        "equal": parse_equal,
        "character": parse_character
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "fragment";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_fragment() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8) === "epubcfi(") {
          result0 = "epubcfi(";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"epubcfi(\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_path();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 41) {
              result2 = ")";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\")\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, pathVal) { 
                
                return { type:"CFIAST", cfiString:pathVal }; 
            })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_indexStep();
        if (result0 !== null) {
          result1 = parse_local_path();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepVal, localPathVal) { 
        
                return { type:"cfiString", path:stepVal, localPath:localPathVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_local_path() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_indexStep();
        if (result1 === null) {
          result1 = parse_indirectionStep();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_indexStep();
            if (result1 === null) {
              result1 = parse_indirectionStep();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = parse_terminus();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, localPathStepVal, termStepVal) { 
        
                return { steps:localPathStepVal, termStep:termStepVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indexStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indexStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_indirectionStep() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2) === "!/") {
          result0 = "!/";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_idAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, stepLengthVal, assertVal) { 
        
                return { type:"indirectionStep", stepLength:stepLengthVal, idAssertion:assertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_terminus() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 58) {
          result0 = ":";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\":\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_integer();
          if (result1 !== null) {
            pos2 = pos;
            if (input.charCodeAt(pos) === 91) {
              result2 = "[";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"[\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_textLocationAssertion();
              if (result3 !== null) {
                if (input.charCodeAt(pos) === 93) {
                  result4 = "]";
                  pos++;
                } else {
                  result4 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"]\"");
                  }
                }
                if (result4 !== null) {
                  result2 = [result2, result3, result4];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, textOffsetValue, textLocAssertVal) { 
        
                return { type:"textTerminus", offsetValue:textOffsetValue, textAssertion:textLocAssertVal[1] };
            })(pos0, result0[1], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_idAssertion() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_value();
        if (result0 !== null) {
          result0 = (function(offset, idVal) { 
        
                return idVal; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_textLocationAssertion() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_csv();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_parameter();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, csvVal, paramVal) { 
        
                return { type:"textLocationAssertion", csv:csvVal, parameter:paramVal }; 
            })(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parameter() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_valueNoSpace();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 61) {
              result2 = "=";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"=\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_valueNoSpace();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, paramLHSVal, paramRHSVal) { 
        
                return { type:"parameter", LHSValue:paramLHSVal, RHSValue:paramRHSVal }; 
            })(pos0, result0[1], result0[3]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_csv() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_value();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_value();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, preAssertionVal, postAssertionVal) { 
        
                return { type:"csv", preAssertion:preAssertionVal, postAssertion:postAssertionVal }; 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_valueNoSpace() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_escapedSpecialChars();
        if (result1 === null) {
          result1 = parse_character();
          if (result1 === null) {
            result1 = parse_space();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_escapedSpecialChars();
            if (result1 === null) {
              result1 = parse_character();
              if (result1 === null) {
                result1 = parse_space();
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, stringVal) { 
        
                return stringVal.join(''); 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_escapedSpecialChars() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_circumflex();
        if (result0 !== null) {
          result1 = parse_circumflex();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_circumflex();
          if (result0 !== null) {
            result1 = parse_squareBracket();
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            result0 = parse_circumflex();
            if (result0 !== null) {
              result1 = parse_parentheses();
              if (result1 !== null) {
                result0 = [result0, result1];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              result0 = parse_circumflex();
              if (result0 !== null) {
                result1 = parse_comma();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                result0 = parse_circumflex();
                if (result0 !== null) {
                  result1 = parse_semicolon();
                  if (result1 !== null) {
                    result0 = [result0, result1];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  result0 = parse_circumflex();
                  if (result0 !== null) {
                    result1 = parse_equal();
                    if (result1 !== null) {
                      result0 = [result0, result1];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, escSpecCharVal) { 
                
                return escSpecCharVal[1]; 
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_number() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        if (/^[1-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[1-9]");
          }
        }
        if (result0 !== null) {
          if (/^[0-9]/.test(input.charAt(pos))) {
            result2 = input.charAt(pos);
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("[0-9]");
            }
          }
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            pos2 = pos;
            result2 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result3 = input.charAt(pos);
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result3 !== null) {
              result2.push(result3);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result2 !== null) {
              if (/^[1-9]/.test(input.charAt(pos))) {
                result3 = input.charAt(pos);
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, intPartVal, fracPartVal) { 
        
                return intPartVal.join('') + "." + fracPartVal.join(''); 
            })(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_integer() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 === null) {
          pos1 = pos;
          if (/^[1-9]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[1-9]");
            }
          }
          if (result0 !== null) {
            result1 = [];
            if (/^[0-9]/.test(input.charAt(pos))) {
              result2 = input.charAt(pos);
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            while (result2 !== null) {
              result1.push(result2);
              if (/^[0-9]/.test(input.charAt(pos))) {
                result2 = input.charAt(pos);
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("[0-9]");
                }
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, integerVal) { 
        
                if (integerVal === "0") { 
                  return "0";
                } 
                else { 
                  return integerVal[0].concat(integerVal[1].join(''));
                }
            })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_space() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_circumflex() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 94) {
          result0 = "^";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"^\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "^"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_doubleQuote() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 34) {
          result0 = "\"";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\"\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return '"'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_squareBracket() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, bracketVal) { return bracketVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_parentheses() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, paraVal) { return paraVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comma() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 44) {
          result0 = ",";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\",\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_semicolon() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_equal() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 61) {
          result0 = "=";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"=\"");
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) { return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_character() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (/^[a-z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-z]");
          }
        }
        if (result0 === null) {
          if (/^[A-Z]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[A-Z]");
            }
          }
          if (result0 === null) {
            if (/^[0-9]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[0-9]");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 45) {
                result0 = "-";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, charVal) { return charVal; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        throw new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
      }
      
      return result;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();
 

    // Description: This model contains the implementation for "instructions" included in the EPUB CFI domain specific language (DSL). 
//   Lexing and parsing a CFI produces a set of executable instructions for processing a CFI (represented in the AST). 
//   This object contains a set of functions that implement each of the executable instructions in the AST. 

EPUBcfi.CFIInstructions = {

	// ------------------------------------------------------------------------------------ //
	//  "PUBLIC" METHODS (THE API)                                                          //
	// ------------------------------------------------------------------------------------ //

	// Description: Follows a step
	// Rationale: The use of children() is important here, as this jQuery method returns a tree of xml nodes, EXCLUDING
	//   CDATA and text nodes. When we index into the set of child elements, we are assuming that text nodes have been 
	//   excluded.
	// REFACTORING CANDIDATE: This should be called "followIndexStep"
	getNextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		// Find the jquery index for the current node
		var $targetNode;
		if (CFIStepValue % 2 == 0) {

			$targetNode = this.elementNodeStep(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}
		else {

			$targetNode = this.inferTargetTextNode(CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist);
		}

		return $targetNode;
	},

	// Description: This instruction executes an indirection step, where a resource is retrieved using a 
	//   link contained on a attribute of the target element. The attribute that contains the link differs
	//   depending on the target. 
	// Note: Iframe indirection will (should) fail if the iframe is not from the same domain as its containing script due to 
	//   the cross origin security policy
	followIndirectionStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var that = this;
		var $contentDocument; 
		var $blacklistExcluded;
		var $startElement;
		var $targetNode;

		// TODO: This check must be expanded to all the different types of indirection step
		// Only expects iframes, at the moment
		if ($currNode === undefined || !$currNode.is("iframe")) {

			throw EPUBcfi.NodeTypeError($currNode, "expected an iframe element");
		}

		// Check node type; only iframe indirection is handled, at the moment
		if ($currNode.is("iframe")) {

			// Get content
			$contentDocument = $currNode.contents();

			// Go to the first XHTML element, which will be the first child of the top-level document object
			$blacklistExcluded = this.applyBlacklist($contentDocument.children(), classBlacklist, elementBlacklist, idBlacklist);
			$startElement = $($blacklistExcluded[0]);

			// Follow an index step
			$targetNode = this.getNextNode(CFIStepValue, $startElement, classBlacklist, elementBlacklist, idBlacklist);

			// Return that shit!
			return $targetNode; 
		}

		// TODO: Other types of indirection
		// TODO: $targetNode.is("embed")) : src
		// TODO: ($targetNode.is("object")) : data
		// TODO: ($targetNode.is("image") || $targetNode.is("xlink:href")) : xlink:href
	},

	// Description: Injects an element at the specified text node
	// Arguments: a cfi text termination string, a jquery object to the current node
	textTermination : function ($currNode, textOffset, elementToInject) {

		// Get the first node, this should be a text node
		if ($currNode === undefined) {

			throw EPUBcfi.NodeTypeError($currNode, "expected a terminating node, or node list");
		} 
		else if ($currNode.length === 0) {

			throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "no nodes found for termination condition");
		}

		$currNode = this.injectCFIMarkerIntoText($currNode, textOffset, elementToInject);
		return $currNode;
	},

	// Description: Checks that the id assertion for the node target matches that on 
	//   the found node. 
	targetIdMatchesIdAssertion : function ($foundNode, idAssertion) {

		if ($foundNode.attr("id") === idAssertion) {

			return true;
		}
		else {

			return false;
		}
	},

	// ------------------------------------------------------------------------------------ //
	//  "PRIVATE" HELPERS                                                                   //
	// ------------------------------------------------------------------------------------ //

	// Description: Step reference for xml element node. Expected that CFIStepValue is an even integer
	elementNodeStep : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {

		var $targetNode;
		var $blacklistExcluded;
		var numElements;
		var jqueryTargetNodeIndex = (CFIStepValue / 2) - 1;

		$blacklistExcluded = this.applyBlacklist($currNode.children(), classBlacklist, elementBlacklist, idBlacklist);
		numElements = $blacklistExcluded.length;

		if (this.indexOutOfRange(jqueryTargetNodeIndex, numElements)) {

			throw EPUBcfi.OutOfRangeError(jqueryTargetNodeIndex, numElements - 1, "");
		}

	    $targetNode = $($blacklistExcluded[jqueryTargetNodeIndex]);
		return $targetNode;
	},

	retrieveItemRefHref : function ($itemRefElement, $packageDocument) {

		return $("#" + $itemRefElement.attr("idref"), $packageDocument).attr("href");
	},

	indexOutOfRange : function (targetIndex, numChildElements) {

		return (targetIndex > numChildElements - 1) ? true : false;
	},

	// Rationale: In order to inject an element into a specific position, access to the parent object 
	//   is required. This is obtained with the jquery parent() method. An alternative would be to 
	//   pass in the parent with a filtered list containing only children that are part of the target text node.
	injectCFIMarkerIntoText : function ($textNodeList, textOffset, elementToInject) {

		var nodeNum;
		var currNodeLength;
		var currTextPosition = 0;
		var nodeOffset;
		var originalText;
		var $injectedNode;
		var $newTextNode;
		// The iteration counter may be incorrect here (should be $textNodeList.length - 1 ??)
		for (nodeNum = 0; nodeNum <= $textNodeList.length; nodeNum++) {

			if ($textNodeList[nodeNum].nodeType === 3) {

				currNodeMaxIndex = ($textNodeList[nodeNum].nodeValue.length - 1) + currTextPosition;
				nodeOffset = textOffset - currTextPosition;

				if (currNodeMaxIndex >= textOffset) {

					// This node is going to be split and the components re-inserted
					originalText = $textNodeList[nodeNum].nodeValue;	

					// Before part
				 	$textNodeList[nodeNum].nodeValue = originalText.slice(0, nodeOffset);

					// Injected element
					$injectedNode = $(elementToInject).insertAfter($textNodeList.eq(nodeNum));

					// After part
					$newTextNode = $(document.createTextNode(originalText.slice(nodeOffset, originalText.length)));
					$($newTextNode).insertAfter($injectedNode);

					return $textNodeList.parent();
				}
				else {

					currTextPosition = currTextPosition + currNodeMaxIndex;
				}
			}
		}

		throw EPUBcfi.TerminusError("Text", "Text offset:" + textOffset, "The offset exceeded the length of the text");
	},

	// Description: This method finds a target text node and then injects an element into the appropriate node
	// Arguments: A step value that is an odd integer. A current node with a set of child elements.
	// Rationale: The possibility that cfi marker elements have been injected into a text node at some point previous to 
	//   this method being called (and thus splitting the original text node into two separate text nodes) necessitates that
	//   the set of nodes that compromised the original target text node are inferred and returned.
	// Notes: Passed a current node. This node should have a set of elements under it. This will include at least one text node, 
	//   element nodes (maybe), or possibly a mix. 
	// REFACTORING CANDIDATE: This method is pretty long. Worth investigating to see if it can be refactored into something clearer.
	inferTargetTextNode : function (CFIStepValue, $currNode, classBlacklist, elementBlacklist, idBlacklist) {
		
		var $elementsWithoutMarkers;
		var currTextNodePosition;
		var logicalTargetPosition;
		var nodeNum;
		var $targetTextNodeList;

		// Remove any cfi marker elements from the set of elements. 
		// Rationale: A filtering function is used, as simply using a class selector with jquery appears to 
		//   result in behaviour where text nodes are also filtered out, along with the class element being filtered.
		$elementsWithoutMarkers = this.applyBlacklist($currNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

		// Convert CFIStepValue to logical index; assumes odd integer for the step value
		logicalTargetPosition = (parseInt(CFIStepValue) + 1) / 2;

		// Set text node position counter
		currTextNodePosition = 1;
		$targetTextNodeList = $elementsWithoutMarkers.filter(
			function () {

				if (currTextNodePosition === logicalTargetPosition) {

					// If it's a text node
					if (this.nodeType === 3) {
						return true; 
					}
					// Any other type of node, move onto the next text node
					else {
						currTextNodePosition++; 
						return false;
					}
				}
				// In this case, don't return any elements
				else {

					// If its the last child and it's not a text node, there are no text nodes after it
					// and the currTextNodePosition shouldn't be incremented
					if (this.nodeType !== 3 && this !== $elementsWithoutMarkers.lastChild) {
						currTextNodePosition++;
					}

					return false;
				}
			}
		);

		// The filtering above should have counted the number of "logical" text nodes; this can be used to 
		// detect out of range errors
		if ($targetTextNodeList.length === 0) {

			throw EPUBcfi.OutOfRangeError(logicalTargetPosition, currTextNodePosition - 1, "Index out of range");
		}

		// return the text node list
		return $targetTextNodeList;
	},

	applyBlacklist : function ($elements, classBlacklist, elementBlacklist, idBlacklist) {

        var $filteredElements;

        $filteredElements = $elements.filter(
            function () {

                var $currElement = $(this);
                var includeInList = true;

                if (classBlacklist) {

                	// Filter each element with the class type
                	$.each(classBlacklist, function (index, value) {

	                    if ($currElement.hasClass(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
                	});
                }

                if (elementBlacklist) {
                	
	                // For each type of element
	                $.each(elementBlacklist, function (index, value) {

	                    if ($currElement.is(value)) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

				if (idBlacklist) {
                	
	                // For each type of element
	                $.each(idBlacklist, function (index, value) {

	                    if ($currElement.attr("id") === value) {
	                    	includeInList = false;

	                    	// Break this loop
	                        return false;
	                    }
	                });
				}

                return includeInList;
            }
        );

        return $filteredElements;
    }
};




    // Description: This is an interpreter that inteprets an Abstract Syntax Tree (AST) for a CFI. The result of executing the interpreter
//   is to inject an element, or set of elements, into an EPUB content document (which is just an XHTML document). These element(s) will
//   represent the position or area in the EPUB referenced by a CFI.
// Rationale: The AST is a clean and readable expression of the step-terminus structure of a CFI. Although building an interpreter adds to the
//   CFI infrastructure, it provides a number of benefits. First, it emphasizes a clear separation of concerns between lexing/parsing a
//   CFI, which involves some complexity related to escaped and special characters, and the execution of the underlying set of steps 
//   represented by the CFI. Second, it will be easier to extend the interpreter to account for new/altered CFI steps (say for references
//   to vector objects or multiple CFIs) than if lexing, parsing and interpretation were all handled in a single step. Finally, Readium's objective is 
//   to demonstrate implementation of the EPUB 3.0 spec. An implementation with a strong separation of concerns that conforms to 
//   well-understood patterns for DSL processing should be easier to communicate, analyze and understand. 
// REFACTORING CANDIDATE: node type errors shouldn't really be possible if the CFI syntax is correct and the parser is error free. 
//   Might want to make the script die in those instances, once the grammar and interpreter are more stable. 
// REFACTORING CANDIDATE: The use of the 'nodeType' property is confusing as this is a DOM node property and the two are unrelated. 
//   Whoops. There shouldn't be any interference, however, I think this should be changed. 

EPUBcfi.Interpreter = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    // Description: Find the content document referenced by the spine item. This should be the spine item 
    //   referenced by the first indirection step in the CFI.
    // Rationale: This method is a part of the API so that the reading system can "interact" the content document 
    //   pointed to by a CFI. If this is not a separate step, the processing of the CFI must be tightly coupled with 
    //   the reading system, as it stands now. 
    getContentDocHref : function (CFI, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        // Decode for URI/IRI escape characters
        var $packageDocument = $(packageDocument);
        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);

        // Check node type; throw error if wrong type
        if (CFIAST === undefined || CFIAST.type !== "CFIAST") { 

            throw EPUBcfi.NodeTypeError(CFIAST, "expected CFI AST root node");
        }

        var $packageElement = $($("package", $packageDocument)[0]);

        // Interpet the path node (the package document step)
        var $currElement = this.interpretIndexStepNode(CFIAST.cfiString.path, $packageElement, classBlacklist, elementBlacklist, idBlacklist);

        // Interpret the local_path node, which is a set of steps and and a terminus condition
        var stepNum = 0;
        var nextStepNode;
        for (stepNum = 0 ; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }

            // Found the content document href referenced by the spine item 
            if ($currElement.is("itemref")) {

                return EPUBcfi.CFIInstructions.retrieveItemRefHref($currElement, $packageDocument);
            }
        }

        // TODO: If you get to here, an itemref element was never found - a runtime error. The cfi is misspecified or 
        //   the package document is messed up.
    },

    // Description: Inject an arbirtary html element into a position in a content document referenced by a CFI
    injectElement : function (CFI, contentDocument, elementToInject, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var currStepNum; 

        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // TODO: detect what kind of terminus; for now, text node termini are the only kind implemented
        $currElement = this.interpretTextTerminusNode(CFIAST.cfiString.localPath.termStep, $currElement, elementToInject);

        // Return the element that was injected into
        return $currElement;
    },

    // Description: This method will return the element or node (say, a text node) that is the final target of the 
    //   the CFI. 
    getTargetElement : function (CFI, contentDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var decodedCFI = decodeURI(CFI);
        var CFIAST = EPUBcfi.Parser.parse(decodedCFI);
        var indirectionNode;
        var indirectionStepNum;
        var currStepNum; 
        
        // Rationale: Since the correct content document for this CFI is already being passed, we can skip to the beginning 
        //   of the indirection step that referenced the content document.
        // Note: This assumes that indirection steps and index steps conform to an interface: an object with stepLength, idAssertion
        indirectionStepNum = this.getFirstIndirectionStepNum(CFIAST);
        indirectionNode = CFIAST.cfiString.localPath.steps[indirectionStepNum];
        indirectionNode.type = "indexStep";

        // Interpret the rest of the steps
        $currElement = this.interpretLocalPath(CFIAST.cfiString, indirectionStepNum, $("html", contentDocument), classBlacklist, elementBlacklist, idBlacklist);

        // Return the element at the end of the CFI
        return $currElement;
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    getFirstIndirectionStepNum : function (CFIAST) {

        // Find the first indirection step in the local path; follow it like a regular step, as the step in the content document it 
        //   references is already loaded and has been passed to this method
        var stepNum = 0;
        for (stepNum; stepNum <= CFIAST.cfiString.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = CFIAST.cfiString.localPath.steps[stepNum];
            if (nextStepNode.type === "indirectionStep") {
                return stepNum;
            }
        }
    },

    // REFACTORING CANDIDATE: cfiString node and start step num could be merged into one argument, by simply passing the 
    //   starting step. 
    interpretLocalPath : function (cfiStringNode, startStepNum, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        var stepNum = startStepNum;
        var nextStepNode;
        for (stepNum; stepNum <= cfiStringNode.localPath.steps.length - 1 ; stepNum++) {
        
            nextStepNode = cfiStringNode.localPath.steps[stepNum];
            if (nextStepNode.type === "indexStep") {

                $currElement = this.interpretIndexStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
            else if (nextStepNode.type === "indirectionStep") {

                $currElement = this.interpretIndirectionStepNode(nextStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist);
            }
        }

        return $currElement;
    },

    interpretIndexStepNode : function (indexStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indexStepNode === undefined || indexStepNode.type !== "indexStep") {

            throw EPUBcfi.NodeTypeError(indexStepNode, "expected index step node");
        }

        // Index step
        var $stepTarget = EPUBcfi.CFIInstructions.getNextNode(indexStepNode.stepLength, $currElement, classBlacklist, elementBlacklist, idBlacklist);

        // Check the id assertion, if it exists
        if (indexStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indexStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indexStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    interpretIndirectionStepNode : function (indirectionStepNode, $currElement, classBlacklist, elementBlacklist, idBlacklist) {

        // Check node type; throw error if wrong type
        if (indirectionStepNode === undefined || indirectionStepNode.type !== "indirectionStep") {

            throw EPUBcfi.NodeTypeError(indirectionStepNode, "expected indirection step node");
        }

        // Indirection step
        var $stepTarget = EPUBcfi.CFIInstructions.followIndirectionStep(
            indirectionStepNode.stepLength, 
            $currElement, 
            classBlacklist, 
            elementBlacklist);

        // Check the id assertion, if it exists
        if (indirectionStepNode.idAssertion) {

            if (!EPUBcfi.CFIInstructions.targetIdMatchesIdAssertion($stepTarget, indirectionStepNode.idAssertion)) {

                throw EPUBcfi.CFIAssertionError(indirectionStepNode.idAssertion, $stepTarget.attr('id'), "Id assertion failed");
            }
        }

        return $stepTarget;
    },

    // REFACTORING CANDIDATE: The logic here assumes that a user will always want to use this terminus
    //   to inject content into the found node. This should be changed to be more flexible.
    interpretTextTerminusNode : function (terminusNode, $currElement, elementToInject) {

        if (terminusNode === undefined || terminusNode.type !== "textTerminus") {

            throw EPUBcfi.NodeTypeError(terminusNode, "expected text terminus node");
        }

        var $elementInjectedInto = EPUBcfi.CFIInstructions.textTermination(
            $currElement, 
            terminusNode.offsetValue, 
            elementToInject);

        return $elementInjectedInto;
    }
};

    // Description: This is a set of runtime errors that the CFI interpreter can throw. 
// Rationale: These error types extend the basic javascript error object so error things like the stack trace are 
//   included with the runtime errors. 

// REFACTORING CANDIDATE: This type of error may not be required in the long run. The parser should catch any syntax errors, 
//   provided it is error-free, and as such, the AST should never really have any node type errors, which are essentially errors
//   in the structure of the AST. This error should probably be refactored out when the grammar and interpreter are more stable.
EPUBcfi.NodeTypeError = function (node, message) {

    function NodeTypeError () {

        this.node = node;
    }

    NodeTypeError.prototype = new Error(message);
    NodeTypeError.constructor = NodeTypeError;

    return new NodeTypeError();
};

// REFACTORING CANDIDATE: Might make sense to include some more specifics about the out-of-rangeyness.
EPUBcfi.OutOfRangeError = function (targetIndex, maxIndex, message) {

    function OutOfRangeError () {

        this.targetIndex = targetIndex;
        this.maxIndex = maxIndex;
    }

    OutOfRangeError.prototype = new Error(message);
    OutOfRangeError.constructor = OutOfRangeError()

    return new OutOfRangeError();
};

// REFACTORING CANDIDATE: This is a bit too general to be useful. When I have a better understanding of the type of errors
//   that can occur with the various terminus conditions, it'll make more sense to revisit this. 
EPUBcfi.TerminusError = function (terminusType, terminusCondition, message) {

    function TerminusError () {

        this.terminusType = terminusType;
        this.terminusCondition = terminusCondition;
    }

    TerminusError.prototype = new Error(message);
    TerminusError.constructor = TerminusError();

    return new TerminusError();
};

EPUBcfi.CFIAssertionError = function (expectedAssertion, targetElementAssertion, message) {

    function CFIAssertionError () {

        this.expectedAssertion = expectedAssertion;
        this.targetElementAssertion = targetElementAssertion;
    }

    CFIAssertionError.prototype = new Error(message);
    CFIAssertionError.constructor = CFIAssertionError();

    return new CFIAssertionError();
};


    EPUBcfi.Generator = {

    // ------------------------------------------------------------------------------------ //
    //  "PUBLIC" METHODS (THE API)                                                          //
    // ------------------------------------------------------------------------------------ //

    // Description: Generates a character offset CFI 
    // Arguments: The text node that contains the offset referenced by the cfi, the offset value, the name of the 
    //   content document that contains the text node, the package document for this EPUB.
    generateCharacterOffsetCFI : function (startTextNode, characterOffset, contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var textNodeStep;
        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        // Check that the text node to start from IS a text node
        if (!startTextNode) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        } else if (startTextNode.nodeType != 3) {
            throw new EPUBcfi.NodeTypeError(startTextNode, "Cannot generate a character offset from a starting point that is not a text node");
        }

        // Check that the character offset is within a valid range for the text node supplied
        if (characterOffset < 0) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, 0, "Character offset cannot be less than 0");
        }
        else if (characterOffset > startTextNode.nodeValue.length) {
            throw new EPUBcfi.OutOfRangeError(characterOffset, startTextNode.nodeValue.length - 1, "character offset cannot be greater than the length of the text node");
        }

        this.validateContentDocumentName(contentDocumentName);
        this.validatePackageDocument(packageDocument, contentDocumentName);

        // Create the text node step
        textNodeStep = this.createCFITextNodeStep($(startTextNode), characterOffset, classBlacklist, elementBlacklist, idBlacklist);

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startTextNode).parent(), "html", classBlacklist, elementBlacklist, idBlacklist) + textNodeStep;

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $("itemref[idref='" + contentDocumentName + "']", $(packageDocument));

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFI = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Return the CFI wrapped with "epubcfi()"
        return "epubcfi(" + packageDocCFI + contentDocCFI + ")";
    },

    generateElementCFI : function (startElement, contentDocumentName, packageDocument, classBlacklist, elementBlacklist, idBlacklist) {

        var contentDocCFI;
        var $itemRefStartNode;
        var packageDocCFI;

        this.validateContentDocumentName(contentDocumentName);
        this.validatePackageDocument(packageDocument, contentDocumentName);        

        // Call the recursive method to create all the steps up to the head element of the content document (the "html" element)
        contentDocCFI = this.createCFIElementSteps($(startElement), "html", classBlacklist, elementBlacklist, idBlacklist);

        // Get the start node (itemref element) that references the content document
        $itemRefStartNode = $("itemref[idref='" + contentDocumentName + "']", $(packageDocument));

        // Create the steps up to the top element of the package document (the "package" element)
        packageDocCFI = this.createCFIElementSteps($itemRefStartNode, "package", classBlacklist, elementBlacklist, idBlacklist);

        // Return the CFI wrapped with "epubcfi()"
        return "epubcfi(" + packageDocCFI + contentDocCFI + ")";
    },

    // ------------------------------------------------------------------------------------ //
    //  "PRIVATE" HELPERS                                                                   //
    // ------------------------------------------------------------------------------------ //

    validateContentDocumentName : function (contentDocumentName) {

        // Check that the idref for the content document has been provided
        if (!contentDocumentName) {
            throw new Error("The idref for the content document, as found in the spine, must be supplied");
        }
    },

    validatePackageDocument : function (packageDocument, contentDocumentName) {
        
        // Check that the package document is non-empty and contains an itemref element for the supplied idref
        if (!packageDocument) {
            throw new Error("A package document must be supplied to generate a CFI");
        }
        else if ($($("itemref[idref='" + contentDocumentName + "']", packageDocument)[0]).length === 0) {
            throw new Error("The idref of the content document could not be found in the spine");
        }
    },

    // Description: Creates a CFI terminating step, to a text node, with a character offset
    // REFACTORING CANDIDATE: Some of the parts of this method could be refactored into their own methods
    createCFITextNodeStep : function ($startTextNode, characterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var CFIIndex;
        var indexOfTextNode;
        var preAssertion;
        var preAssertionStartIndex;
        var textLength;
        var postAssertion;
        var postAssertionEndIndex;

        // Find text node position in the set of child elements, ignoring any blacklisted elements 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node index in the parent list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var indexOfFirstInSequence;
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        // Set index as the first in the adjacent sequence of text nodes, or as the index of the current node if this 
                        //   node is a standard one sandwiched between two element nodes. 
                        if (prevNodeWasTextNode) {
                            indexOfTextNode = indexOfFirstInSequence;
                        }
                        else {
                            indexOfTextNode = index;
                        }
                        
                        // Break out of .each loop
                        return false; 
                    }

                    // Save this index as the first in sequence of adjacent text nodes, if it is not already set by this point
                    prevNodeWasTextNode = true;
                    if (!indexOfFirstInSequence) {
                        indexOfFirstInSequence = index;
                    }
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                    indexOfFirstInSequence = undefined;
                }
            }
        );

        // Convert the text node index to a CFI odd-integer representation
        CFIIndex = (indexOfTextNode * 2) + 1;

        // TODO: text assertions are not in the grammar yet, I think, or they're just causing problems. This has
        //   been temporarily removed. 

        // Add pre- and post- text assertions
        // preAssertionStartIndex = (characterOffset - 3 >= 0) ? characterOffset - 3 : 0;
        // preAssertion = $startTextNode[0].nodeValue.substring(preAssertionStartIndex, characterOffset);

        // textLength = $startTextNode[0].nodeValue.length;
        // postAssertionEndIndex = (characterOffset + 3 <= textLength) ? characterOffset + 3 : textLength;
        // postAssertion = $startTextNode[0].nodeValue.substring(characterOffset, postAssertionEndIndex);

        // Gotta infer the correct character offset, as well

        // Return the constructed CFI text node step
        return "/" + CFIIndex + ":" + characterOffset;
         // + "[" + preAssertion + "," + postAssertion + "]";
    },

    // Description: A set of adjacent text nodes can be inferred to have been a single text node in the original document. As such, 
    //   if the character offset is specified for one of the adjacent text nodes, the true offset for the original node must be
    //   inferred.
    findOriginalTextNodeCharOffset : function ($startTextNode, specifiedCharacterOffset, classBlacklist, elementBlacklist, idBlacklist) {

        var $parentNode;
        var $contentsExcludingMarkers;
        var textLength;
        
        // Find text node position in the set of child elements, ignoring any cfi markers 
        $parentNode = $startTextNode.parent();
        $contentsExcludingMarkers = EPUBcfi.CFIInstructions.applyBlacklist($parentNode.contents(), classBlacklist, elementBlacklist, idBlacklist);

        // Find the text node number in the list, inferring nodes that were originally a single text node
        var prevNodeWasTextNode;
        var originalCharOffset = -1; // So the character offset is a 0-based index; we'll be adding lengths of text nodes to this number
        $.each($contentsExcludingMarkers, 
            function (index) {

                // If this is a text node, check if it matches and return the current index
                if (this.nodeType === 3) {

                    if (this === $startTextNode[0]) {

                        if (prevNodeWasTextNode) {
                            originalCharOffset = originalCharOffset + specifiedCharacterOffset;
                        }
                        else {
                            originalCharOffset = specifiedCharacterOffset;
                        }

                        return false; // Break out of .each loop
                    }
                    else {

                        originalCharOffset = originalCharOffset + this.length;
                    }

                    // save this index as the first in sequence of adjacent text nodes, if not set
                    prevNodeWasTextNode = true;
                }
                // This node is not a text node
                else {
                    prevNodeWasTextNode = false;
                }
            }
        );

        return originalCharOffset;
    },

    createCFIElementSteps : function ($currNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) {

        var $blacklistExcluded;
        var $parentNode;
        var currNodePosition;
        var CFIPosition;
        var idAssertion;
        var elementStep; 

        // Find position of current node in parent list
        $blacklistExcluded = EPUBcfi.CFIInstructions.applyBlacklist($currNode.parent().children(), classBlacklist, elementBlacklist, idBlacklist);
        $.each($blacklistExcluded, 
            function (index, value) {

                if (this === $currNode[0]) {

                    currNodePosition = index;

                    // Break loop
                    return false;
                }
        });

        // Convert position to the CFI even-integer representation
        CFIPosition = (currNodePosition + 1) * 2;

        // Create CFI step with id assertion, if the element has an id
        if ($currNode.attr("id")) {
            elementStep = "/" + CFIPosition + "[" + $currNode.attr("id") + "]";
        }
        else {
            elementStep = "/" + CFIPosition;
        }

        // If a parent is an html element return the (last) step for this content document, otherwise, continue.
        //   Also need to check if the current node is the top-level element. This can occur if the start node is also the
        //   top level element.
        $parentNode = $currNode.parent();
        if ($parentNode.is(topLevelElement) || $currNode.is(topLevelElement)) {
            
            // If the top level node is a type from which an indirection step, add an indirection step character (!)
            // REFACTORING CANDIDATE: It is possible that this should be changed to: if (topLevelElement = 'package') do
            //   not return an indirection character. Every other type of top-level element may require an indirection
            //   step to navigate to, thus requiring that ! is always prepended. 
            if (topLevelElement === 'html') {
                return "!" + elementStep;
            }
            else {
                return elementStep;
            }
        }
        else {
            return this.createCFIElementSteps($parentNode, topLevelElement, classBlacklist, elementBlacklist, idBlacklist) + elementStep;
        }
    }
};

    if (global.EPUBcfi) {

        throw new Error('The EPUB cfi library has already been defined');
    }
    else {

        global.EPUBcfi = EPUBcfi;
    }
}) (typeof window === 'undefined' ? this : window);
